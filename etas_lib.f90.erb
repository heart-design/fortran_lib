<%-
  T_DECLS = [
    [:r, 'Real(kind=real64)'],
    [:q, 'Real(kind=real128)'],
    [:dr, 'type(Dual64_2_5)'],
    [:dq, 'type(Dual128_2_5)'],
  ]
-%>

#include "fortran_lib.h"
module etas_lib
   USE_FORTRAN_LIB_H
   use, intrinsic:: iso_fortran_env, only: input_unit, output_unit, error_unit, real64, int64, real128
   use, non_intrinsic:: ad_lib, only: Dual64_2_5, Dual128_2_5
   use, non_intrinsic:: ad_lib, only: operator(+), operator(*), operator(-), operator(/), operator(**), operator(==)
   use, non_intrinsic:: ad_lib, only: exp, log, sum, dot_product

   implicit none

   private
   public:: intensity_etas
   public:: log_likelihood_etas
   public:: omori_integrate

   <%- T_DECLS.each{|t, _| -%>
      <%-
        [
          :intensity_etas,
          :log_likelihood_etas,
          :sum_log_lambda_neg_p,
          :lambda_integrate,
          :kernel_coeff,
          :kernel_integrate,
          :omori_integrate,
          :utsu_seki,
        ].each{|fn|
      -%>
         interface <%= fn %>
            module procedure <%= fn %><%= t %>
         end interface <%= fn %>
      <%- } -%>

      interface omori_neg_p
         module procedure omori_t_0_neg_p<%= t %>
      end interface omori_neg_p

      interface lambda_neg_p
         module procedure lambda_neg_p_i<%= t %>
         module procedure lambda_neg_p_t<%= t %>
         module procedure lambda_neg_p_j_t<%= t %>
      end interface lambda_neg_p
   <%- } -%>

contains

   <%- T_DECLS.each{|t, decl| -%>
      function intensity_etas<%= t %>(t, normalize_interval, c, p, alpha, K, mu, ts, ms) result(ret)
         <%= decl %>:: ret
         Real(kind=real64), intent(in):: t, normalize_interval, ts(:), ms(size(ts))
         <%= decl %>, intent(in):: c, p, alpha, K, mu
         <%= decl %>:: coeffs(size(ms))
         <%= decl %>:: mu_normalized

         coeffs = kernel_coeff(ms, c, p, alpha, K, normalize_interval)
         mu_normalized = mu/normalize_interval
         ret = lambda_neg_p(t, c, -p, mu_normalized, ts, coeffs)
      end function intensity_etas<%= t %>


      function log_likelihood_etas<%= t %>(t_len, normalize_interval, c, p, alpha, K, mu, ts, ms) result(ret)
         Integer(kind=int64):: one = 1
         <%= decl %>:: ret
         Real(kind=real64), intent(in):: t_len, normalize_interval, ts(:), ms(size(ts))
         <%= decl %>, intent(in):: c, p, alpha, K, mu
         <%= decl %>:: coeffs(size(ms))
         <%= decl %>:: mu_normalized

         coeffs = kernel_coeff(ms, c, p, alpha, K, normalize_interval)
         mu_normalized = mu/normalize_interval
         !$omp parallel
         !$omp single
         ret = sum_log_lambda_neg_p(one, size(ts, kind=kind(one)), c, -p, mu_normalized, ts, coeffs) - lambda_integrate(t_len, c, p, mu_normalized, ts, coeffs)
         !$omp end single
         !$omp end parallel
      end function log_likelihood_etas<%= t %>


      recursive function sum_log_lambda_neg_p<%= t %>(i1, i2, c, neg_p, mu_normalized, ts, coeffs) result(ret)
         Integer(kind=int64), parameter:: blocksize = 2**4
         <%= decl %>:: ret, ret1, ret2
         Integer(kind=kind(blocksize)), intent(in):: i1, i2
         Real(kind=real64), intent(in):: ts(:)
         <%= decl %>, intent(in):: c, neg_p, mu_normalized, coeffs(size(ts))
         Integer(kind=int64):: i, i_mid

         if(i1 + blocksize > i2)then
            ret = log(lambda_neg_p(i1, c, neg_p, mu_normalized, ts, coeffs))
            do i = i1 + 1, i2
               ret = ret + log(lambda_neg_p(i, c, neg_p, mu_normalized, ts, coeffs))
            end do
         else
            i_mid = (i1 + i2)/2
            !$omp task shared(ret2) untied
            ret2 = sum_log_lambda_neg_p(i_mid + 1, i2, c, neg_p, mu_normalized, ts, coeffs)
            !$omp end task
            ret1 = sum_log_lambda_neg_p(i1, i_mid, c, neg_p, mu_normalized, ts, coeffs)
            !$omp taskwait
            ret = ret1 + ret2
         end if
      end function sum_log_lambda_neg_p<%= t %>


      pure function lambda_neg_p_i<%= t %>(i, c, neg_p, mu_normalized, ts, coeffs) result(ret)
         <%= decl %>:: ret
         Integer(kind=int64), intent(in):: i
         Real(kind=real64), intent(in):: ts(:)
         <%= decl %>, intent(in):: c, neg_p, mu_normalized, coeffs(size(ts))
         Real(kind=kind(ts)):: ti
         Integer(kind=kind(i)):: j

         ti = ts(i)
         do j = i - 1, 1, -1
            if(ts(j) < ti) exit
         end do
         ret = lambda_neg_p(j, ti, c, neg_p, mu_normalized, ts, coeffs)
      end function lambda_neg_p_i<%= t %>


      pure function lambda_neg_p_t<%= t %>(t, c, neg_p, mu_normalized, ts, coeffs) result(ret)
         <%= decl %>:: ret
         Real(kind=real64), intent(in):: t, ts(:)
         <%= decl %>, intent(in):: c, neg_p, mu_normalized, coeffs(size(ts))
         Integer(kind=int64):: i, j, n

         n = size(ts, kind=kind(j))
         j = n
         do i = 1, n
            if(ts(i) >= t)then
               j = i - 1
               exit
            end if
         end do
         ret = lambda_neg_p(j, t, c, neg_p, mu_normalized, ts, coeffs)
      end function lambda_neg_p_t<%= t %>


      pure function lambda_neg_p_j_t<%= t %>(j, t, c, neg_p, mu_normalized, ts, coeffs) result(ret)
         <%= decl %>:: ret
         Integer(kind=int64), intent(in):: j
         Real(kind=real64), intent(in):: t, ts(:)
         <%= decl %>, intent(in):: c, neg_p, mu_normalized, coeffs(size(ts))

         ret = mu_normalized + dot_product(coeffs(:j), omori_neg_p(c + (t - ts(:j)), neg_p))
      end function lambda_neg_p_j_t<%= t %>


      pure function lambda_integrate<%= t %>(t_len, c, p, mu_normalized, ts, coeffs) result(ret)
         <%= decl %>:: ret
         Real(kind=real64), intent(in):: t_len, ts(:)
         <%= decl %>, intent(in):: c, p, mu_normalized, coeffs(size(ts))

         ! todo: sum(kernel_integrate(t_len - ts, coeffs, c, p))
         ret = t_len*mu_normalized + sum(kernel_integrate(t_len - ts, coeffs, c, p))
      end function lambda_integrate<%= t %>


      elemental function kernel_integrate<%= t %>(t, K, c, p) result(ret)
         <%= decl %>:: ret
         Real(kind=real64), intent(in):: t
         <%= decl %>, intent(in)::  K, c, p

         ret = K*omori_integrate(t, c, p)
      end function kernel_integrate<%= t %>


      elemental function kernel_coeff<%= t %>(dm, c, p, alpha, K, normalize_interval) result(ret)
         <%= decl %>:: ret
         Real(kind=real64), intent(in):: dm, normalize_interval
         <%= decl %>, intent(in):: c, p, alpha, K

         ! normalization by `omori_integrate` reduces correlation of objective function and improves convergence rate.
         ret = K*utsu_seki(dm, alpha)/omori_integrate(normalize_interval, c, p)
      end function kernel_coeff<%= t %>


      elemental function omori_t_0_neg_p<%= t %>(t, neg_p) result(ret)
         <%= decl %>:: ret
         <%= decl %>, intent(in):: t, neg_p

         ret = t**neg_p
      end function omori_t_0_neg_p<%= t %>


      elemental function omori_integrate<%= t %>(t, c, p) result(ret)
         <%= decl %>:: ret
         Real(kind=real64), intent(in):: t
         <%= decl %>, intent(in):: c, p

         if(p == 1)then
            ret = log(t + c)*(t + c)**(1 - p) - log(c)*c**(1 - p)
            ! To correctly calculate Jacobian and Hessian by automatic differentiation,
            ! this redundant form should not be simplified by using p == 1.
            ! If I wrote the above code like:
            ! ret = log((t + c)/c)
            ! ∂omori_integrate/∂p will be 0, which is inappropriate, if p == 1.
         else
            ret = ((t + c)**(1 - p) - c**(1 - p))/(1 - p)
         end if
      end function omori_integrate<%= t %>


      elemental function utsu_seki<%= t %>(dm, alpha) result(ret)
         <%= decl %>:: ret
         Real(kind=real64), intent(in):: dm
         <%= decl %>, intent(in):: alpha

         ret = exp(alpha*dm)
      end function utsu_seki<%= t %>
   <%- } -%>
end module etas_lib
