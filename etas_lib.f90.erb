<%-
  KS = [
    64,
    128,
  ]
  RD = [
    :Real,
    :Dual,
  ]
  RD_KS = RD.product(KS)

  def _decl(t, k)
    if t == :Real
      "#{t}(kind=real#{k})"
    else
      "type(#{t}#{k}_2_5)"
    end
  end

  def _suffix(t, k)
    "#{t}#{k}"
  end
-%>

#include "fortran_lib.h"
module etas_lib
   USE_FORTRAN_LIB_H
   use, intrinsic:: iso_fortran_env, only: input_unit, output_unit, error_unit, real64, int64, real128
   use, non_intrinsic:: ad_lib, only: Dual64_2_5, Dual128_2_5
   use, non_intrinsic:: ad_lib, only: operator(+), operator(*), operator(-), operator(/), operator(**), operator(==)
   use, non_intrinsic:: ad_lib, only: exp, log, sum, dot_product

   implicit none

   private
   public:: intensity_etas
   public:: log_likelihood_etas
   public:: omori_integrate
   public:: utsu_seki
   <%- [:ge, :le, :lt].each{|name| -%>
      public:: index_<%= name %>
   <%- } -%>
   public:: load

   <%- RD_KS.each{|t, k| -%>
      <%- suffix = _suffix(t, k) -%>
      <%-
        [
          :intensity_etas,
          :lambda_integrate,
          :kernel_coeff,
          :kernel_integrate,
          :omori_integrate,
          :utsu_seki,
        ].each{|fn|
      -%>
         interface <%= fn %>
            module procedure <%= fn %><%= suffix %>
         end interface <%= fn %>
      <%- } -%>

      interface log_likelihood_etas
         module procedure log_likelihood_etas<%= suffix %>
         module procedure log_likelihood_etas_range<%= suffix %>
      end interface log_likelihood_etas

      interface omori_neg_p
         module procedure omori_t_0_neg_p<%= suffix %>
      end interface omori_neg_p

      interface lambda_neg_p
         module procedure lambda_neg_p_i<%= suffix %>
         module procedure lambda_neg_p_t<%= suffix %>
         module procedure lambda_neg_p_j_t<%= suffix %>
      end interface lambda_neg_p

      <%- if t == :Real -%>
         <%- [:ge, :le, :lt].each{|name| -%>
            interface index_<%= name %>
               module procedure index_<%= name %><%= suffix %>
            end interface index_<%= name %>
         <%- } -%>

         interface load
            module procedure loadEtasInputs<%= k %>
         end interface load
      <%- end -%>
   <%- } -%>

   <%- KS.each{|k| -%>
      type, public:: EtasInputs<%= k %>
         Real(kind=real<%= k %>):: m_for_K
         Real(kind=real<%= k %>):: t_normalize_len
         Real(kind=real<%= k %>):: t_pre
         Real(kind=real<%= k %>):: t_end
         Real(kind=real<%= k %>), allocatable:: ts(:)
         Real(kind=real<%= k %>), allocatable:: ms(:)
         Integer(kind=int64):: n
      end type EtasInputs<%= k %>
   <%- } -%>

contains

   <%- RD_KS.each{|t, k| -%>
      <%- decl = _decl(t, k) -%>
      <%- suffix = _suffix(t, k) -%>
      function intensity_etas<%= suffix %>(t, t_normalize_len, mu, K, c, alpha, p, ts, dms) result(ret)
         <%= decl %>:: ret
         Real(kind=real<%= k %>), intent(in):: t, t_normalize_len, ts(:), dms(size64(ts))
         <%= decl %>, intent(in):: mu, K, c, alpha, p
         <%= decl %>:: coeffs(size64(dms))
         <%= decl %>:: mu_normalized

         coeffs = kernel_coeff(dms, K, c, alpha, p, t_normalize_len)
         mu_normalized = mu/t_normalize_len
         ret = lambda_neg_p(t, c, -p, mu_normalized, ts, coeffs)
      end function intensity_etas<%= suffix %>


      function log_likelihood_etas<%= suffix %>(t_begin, t_end, t_normalize_len, mu, K, c, alpha, p, ts, dms, i_begin, targets) result(ret)
         <%= decl %>:: ret
         Real(kind=real<%= k %>), intent(in):: t_begin, t_end, t_normalize_len, ts(:), dms(size64(ts))
         Integer(kind=int64), intent(in):: i_begin
         Logical, intent(in):: targets(size64(ts))
         <%= decl %>, intent(in):: mu, K, c, alpha, p
         <%= decl %>:: coeffs(size64(dms))
         <%= decl %>:: mu_normalized, neg_p
         <%= decl %>:: log_lambdas(size64(ts) - i_begin + 1)
         Integer(kind=kind(i_begin)):: i, n

         n = size(ts, kind=kind(n))
         ASSERT(t_begin <= ts(i_begin) .and. ts(i_begin) <= ts(n) .and. ts(n) <= t_end)
         coeffs = kernel_coeff(dms, K, c, alpha, p, t_normalize_len)
         mu_normalized = mu/t_normalize_len
         neg_p = -p
         <%- if t == :Real -%>
            log_lambdas = 0
         <%- else -%>
            ! log_lambdas::Dual is already initialized to 0
         <%- end -%>
         ! schedule(guided) is superior to schedule(static, 1), schedule(dynamic) or schedule(auto)
         ! reversing the loop order degrades performance and result in 2-fold slowdown.
         !$omp parallel do schedule(guided)
         do i = i_begin, n
            if(targets(i))then
               log_lambdas(i) = log(lambda_neg_p(i, c, neg_p, mu_normalized, ts, coeffs))
            end if
         end do
         ! Use pairwise summation instead of omp reduction(+:ret1)
         ret = sum(log_lambdas) - lambda_integrate(t_begin, t_end, c, p, mu_normalized, ts, coeffs, i_begin)
      end function log_likelihood_etas<%= suffix %>


      function log_likelihood_etas_range<%= suffix %>(t_begin, t_end, t_normalize_len, mu, K, c, alpha, p, ts, dms, targets) result(ret)
         Integer(kind=int64), parameter:: one = 1
         <%= decl %>:: ret
         Real(kind=real<%= k %>), intent(in):: t_begin, t_end, t_normalize_len, ts(:), dms(size64(ts))
         <%= decl %>, intent(in):: mu, K, c, alpha, p
         Integer(kind=kind(one)):: n, i_begin, i_end
         Logical, intent(in):: targets(size64(ts))

         n = size(ts, kind=kind(n))
         i_begin = index_ge(ts, t_begin, one, n)
         i_end = index_le(ts, t_end, i_begin, n)
         ASSERT(1 <= i_begin)
         ASSERT(i_begin <= i_end)
         ASSERT(i_end <= n)
         ret = log_likelihood_etas(t_begin, t_end, t_normalize_len, mu, K, c, alpha, p, ts(:i_end), dms(:i_end), i_begin, targets(:i_end))
      end function log_likelihood_etas_range<%= suffix %>


      pure function lambda_neg_p_i<%= suffix %>(i, c, neg_p, mu_normalized, ts, coeffs) result(ret)
         <%= decl %>:: ret
         Integer(kind=int64), intent(in):: i
         Real(kind=real<%= k %>), intent(in):: ts(:)
         <%= decl %>, intent(in):: c, neg_p, mu_normalized, coeffs(size64(ts))
         Real(kind=kind(ts)):: ti
         Integer(kind=kind(i)):: j

         ti = ts(i)
         do j = i - 1, 1, -1
            if(ts(j) < ti) exit
         end do
         ret = lambda_neg_p(j, ti, c, neg_p, mu_normalized, ts, coeffs)
      end function lambda_neg_p_i<%= suffix %>


      pure function lambda_neg_p_t<%= suffix %>(t, c, neg_p, mu_normalized, ts, coeffs) result(ret)
         <%= decl %>:: ret
         Real(kind=real<%= k %>), intent(in):: t, ts(:)
         <%= decl %>, intent(in):: c, neg_p, mu_normalized, coeffs(size64(ts))

         ret = lambda_neg_p(index_lt(ts, t, int(1, kind=int64), size64(ts)), t, c, neg_p, mu_normalized, ts, coeffs)
      end function lambda_neg_p_t<%= suffix %>


      pure function lambda_neg_p_j_t<%= suffix %>(j, t, c, neg_p, mu_normalized, ts, coeffs) result(ret)
         <%= decl %>:: ret
         Integer(kind=int64), intent(in):: j
         Real(kind=real<%= k %>), intent(in):: t, ts(:)
         <%= decl %>, intent(in):: c, neg_p, mu_normalized, coeffs(size64(ts))

         ret = mu_normalized + dot_product(coeffs(:j), omori_neg_p(c + (t - ts(:j)), neg_p))
      end function lambda_neg_p_j_t<%= suffix %>


      pure function lambda_integrate<%= suffix %>(t_begin, t_end, c, p, mu_normalized, ts, coeffs, i_begin) result(ret)
         <%= decl %>:: ret
         Real(kind=real<%= k %>), intent(in):: t_begin, t_end, ts(:)
         Integer(kind=int64), intent(in):: i_begin
         <%= decl %>, intent(in):: c, p, mu_normalized, coeffs(size64(ts))

         ret = (t_end - t_begin)*mu_normalized + sum(kernel_integrate(t_end - ts, coeffs, c, p)) - sum(kernel_integrate(t_begin - ts(:(i_begin - 1)), coeffs(:(i_begin - 1)), c, p))
      end function lambda_integrate<%= suffix %>


      elemental function kernel_integrate<%= suffix %>(t, K, c, p) result(ret)
         <%= decl %>:: ret
         Real(kind=real<%= k %>), intent(in):: t
         <%= decl %>, intent(in)::  K, c, p

         ret = K*omori_integrate(t, c, p)
      end function kernel_integrate<%= suffix %>


      elemental function kernel_coeff<%= suffix %>(dm, K, c, alpha, p, t_normalize_len) result(ret)
         <%= decl %>:: ret
         Real(kind=real<%= k %>), intent(in):: dm, t_normalize_len
         <%= decl %>, intent(in):: K, c, alpha, p

         ! normalization by `omori_integrate` reduces correlation of objective function and improves convergence rate.
         ret = K*utsu_seki(dm, alpha)/omori_integrate(t_normalize_len, c, p)
      end function kernel_coeff<%= suffix %>


      elemental function omori_t_0_neg_p<%= suffix %>(t, neg_p) result(ret)
         <%= decl %>:: ret
         <%= decl %>, intent(in):: t, neg_p

         ret = t**neg_p
      end function omori_t_0_neg_p<%= suffix %>


      elemental function omori_integrate<%= suffix %>(t, c, p) result(ret)
         <%= decl %>:: ret
         Real(kind=real<%= k %>), intent(in):: t
         <%= decl %>, intent(in):: c, p

         if(p == 1)then
            ret = log(t + c)*(t + c)**(1 - p) - log(c)*c**(1 - p)
            ! To correctly calculate gradient and Hessian by automatic differentiation,
            ! this redundant form should not be simplified by using p == 1.
            ! If I wrote the above code like:
            ! ret = log((t + c)/c)
            ! ∂omori_integrate/∂p will erroneously be 0.
         else
            ret = ((t + c)**(1 - p) - c**(1 - p))/(1 - p)
         end if
      end function omori_integrate<%= suffix %>


      elemental function utsu_seki<%= suffix %>(dm, alpha) result(ret)
         <%= decl %>:: ret
         Real(kind=real<%= k %>), intent(in):: dm
         <%= decl %>, intent(in):: alpha

         ret = exp(alpha*dm)
      end function utsu_seki<%= suffix %>

      <%- if t == :Real -%>
         pure recursive function index_ge<%= suffix %>(ts, t, i1, i2) result(ret)
            ! Return the smallest ret where ts(ret) >= t
            ! Assumptions:
            ! - ts is sorted in ascending order
            Integer(kind=int64):: ret
            <%= decl %>, intent(in):: ts(:), t
            Integer(kind=int64), intent(in):: i1, i2
            Integer(kind=kind(i1)):: i_mid

            if(i1 == i2)then
               if(ts(i1) < t)then
                  ret = i1 + 1
               else
                  ret = i1
               end if
            else
               i_mid = (i1 + i2)/2 ! this will not overflow in practice
               if(ts(i_mid) < t)then
                  ret = index_ge(ts, t, i_mid + 1, i2)
               else
                  ret = index_ge(ts, t, i1, i_mid)
               end if
            end if
         end function index_ge<%= suffix %>

         pure recursive function index_le<%= suffix %>(ts, t, i1, i2) result(ret)
            ! Return the largest ret where ts(ret) <= t
            ! Assumptions:
            ! - ts is sorted in ascending order
            Integer(kind=int64):: ret
            <%= decl %>, intent(in):: ts(:), t
            Integer(kind=int64), intent(in):: i1, i2
            Integer(kind=kind(i1)):: i_mid

            if(i1 == i2)then
               if(t < ts(i1))then
                  ret = i1 - 1
               else
                  ret = i1
               end if
            else
               i_mid = (i1 + i2)/2 + 1 ! this will not overflow in practice
               if(t < ts(i_mid))then
                  ret = index_le(ts, t, i1, i_mid - 1)
               else
                  ret = index_le(ts, t, i_mid, i2)
               end if
            end if
         end function index_le<%= suffix %>

         pure recursive function index_lt<%= suffix %>(ts, t, i1, i2) result(ret)
            ! Return the largest ret where ts(ret) < t
            ! Assumptions:
            ! - ts is sorted in ascending order
            Integer(kind=int64):: ret
            <%= decl %>, intent(in):: ts(:), t
            Integer(kind=int64), intent(in):: i1, i2
            Integer(kind=kind(i1)):: i_mid

            if(i1 == i2)then
               if(ts(i1) < t)then
                  ret = i1
               else
                  ret = i1 - 1
               end if
            else
               i_mid = (i1 + i2)/2 ! this will not overflow in practice
               if(ts(i_mid) < t)then
                  ret = index_lt(ts, t, i_mid + 1, i2)
               else
                  ret = index_lt(ts, t, i1, i_mid)
               end if
            end if
         end function index_lt<%= suffix %>

         subroutine loadEtasInputs<%= k %>(self, unit)
            Integer(kind=int64), parameter:: one = 1
            type(EtasInputs<%= k %>), intent(out):: self
            Integer(kind=kind(input_unit)), intent(in):: unit
            Real(kind=kind(self%ts)), allocatable:: ts(:), ms(:)
            Integer(kind=kind(self%n)):: i, n, i_pre, i_end

            read(unit, *) self%m_for_K
            read(unit, *) self%t_normalize_len
            ASSERT(self%t_normalize_len > 0)
            read(unit, *) self%t_pre
            read(unit, *) self%t_end
            ASSERT(self%t_pre <= self%t_end)
            read(unit, *) n
            ASSERT(n > 0)
            allocate(ts(n))
            allocate(ms(n))
            i_end = n
            do i = 1, n
               read(unit, *) ts(i), ms(i)
               if(i > 1)then
                  ASSERT(ts(i) >= ts(i - 1))
                  if(ts(i) > self%t_end)then
                     i_end = i
                     exit
                  end if
               end if
            end do
            i_pre = index_ge(ts, self%t_pre, one, i_end)
            ! todo: search from tail should be much faster
            i_end = index_le(ts, self%t_end, i_pre, i_end)
            ASSERT(i_pre <= i_end)

            self%n = i_end - i_pre + 1
            ENSURE_DEALLOCATED(self%ts)
            ENSURE_DEALLOCATED(self%ms)
            allocate(self%ts(self%n), source=ts(i_pre:i_end))
            allocate(self%ms(self%n), source=ms(i_pre:i_end))
         end subroutine loadEtasInputs<%= k %>
      <%- end -%>
   <%- } -%>
end module etas_lib
