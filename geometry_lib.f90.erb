<%-
   KS = [32, 64, 128]
-%>

#include "fortran_lib.h"
module geometry_lib
   USE_FORTRAN_LIB_H
   use, intrinsic:: iso_fortran_env, only: input_unit, output_unit, error_unit
   use, intrinsic:: iso_fortran_env, only: int64
   <%- KS.each{|k| -%>
      use, intrinsic:: iso_fortran_env, only: real<%= k %>
   <%- } -%>
   use, non_intrinsic:: math_lib, only: mod1

   implicit none

   private
   public:: is_in
   public:: size
   public:: load
   public:: shape_of
   public:: distance_and_angles_2d
   public:: angle_2d
   public:: perpendicular_2d
   public:: distance_2d
   public:: cross_2d

   ! Interface

   <%- KS.each{|k| -%>
      interface is_in
         module procedure is_in_LeftConvexPolygon<%= k %>
      end interface is_in

      interface size
         module procedure size_LeftConvexPolygon<%= k %>
      end interface size

      interface load
         module procedure load_LeftConvexPolygon<%= k %>
      end interface load

      interface shape_of
         module procedure shape_of<%= k %>
      end interface shape_of

      interface distance_and_angles_2d
         module procedure distance_and_angles_2d<%= k %>
      end interface distance_and_angles_2d

      interface angle_2d
         module procedure angle_2d<%= k %>
      end interface angle_2d

      interface perpendicular_2d
         module procedure perpendicular_2d_v<%= k %>
         module procedure perpendicular_2d_uv<%= k %>
      end interface perpendicular_2d

      interface distance_2d
         module procedure distance_2d<%= k %>
      end interface distance_2d

      interface cross_2d
         module procedure cross_2d_u_v<%= k %>
         module procedure cross_2d_u1_u2_v1_v2<%= k %>
      end interface cross_2d
   <%- } -%>


   <%- KS.each{|k| -%>
      type, public:: LeftConvexPolygon<%= k %>
         Real(kind=real<%= k %>), allocatable:: xs(:)
         Real(kind=real<%= k %>), allocatable:: ys(:)
      end type LeftConvexPolygon<%= k %>
   <%- } -%>


   Integer, parameter, public:: point = 0
   Integer(kind=kind(point)), parameter, public:: line = 1
   Integer(kind=kind(point)), parameter, public:: left_convex_polygon = 2
   Integer(kind=kind(point)), parameter, public:: right_convex_polygon = 3
   Integer(kind=kind(point)), parameter, public:: other = 4


contains


   <%- KS.each{|k| -%>
      elemental function is_in_LeftConvexPolygon<%= k %>(self, x, y) result(ret)
         Logical:: ret
         type(LeftConvexPolygon<%= k %>), intent(in):: self
         Real(kind=real<%= k %>), intent(in):: x, y

         Integer(kind=int64):: i, n

         n = size(self)
         ret = .true.
         do i = 1, n
            if(cross_2d(self%xs(i), self%ys(i), self%xs(mod1(i + 1, n)), self%ys(mod1(i + 1, n))) < 0)then
               ret = .false.
               return
            end if
         end do
      end function is_in_LeftConvexPolygon<%= k %>


      elemental function size_LeftConvexPolygon<%= k %>(self) result(ret)
         Integer(kind=int64):: ret
         type(LeftConvexPolygon<%= k %>), intent(in):: self

         ret = size(self%xs, kind=kind(ret))
      end function size_LeftConvexPolygon<%= k %>


      subroutine load_LeftConvexPolygon<%= k %>(self, unit)
         type(LeftConvexPolygon<%= k %>), intent(out):: self
         Integer(kind=kind(input_unit)), intent(in):: unit

         Integer(kind=int64):: i, n
         Integer(kind=kind(left_convex_polygon)):: shape

         read(unit) n
         ASSERT(n >= 3)
         allocate(self%xs(n))
         allocate(self%ys(n))
         do i = 1, n
            read(unit, *) self%xs(i), self%ys(i)
         end do

         shape = shape_of(self%xs, self%ys)
         ASSERT(shape == left_convex_polygon .or. shape == right_convex_polygon)
         if(shape == right_convex_polygon)then
            self%xs(:) = self%xs(n:1:-1)
            self%ys(:) = self%ys(n:1:-1)
         end if
      end subroutine load_LeftConvexPolygon<%= k %>


      function shape_of<%= k %>(xs, ys) result(ret)
         Integer(kind=kind(left_convex_polygon)):: ret
         Real(kind=real<%= k %>), intent(in):: xs(:), ys(size64(xs))

         Real(kind=real<%= k %>):: sig
         Integer(kind=int64):: i, n

         n = size(xs, kind=kind(n))
         select case(n)
         case(:0)
            ret = other
         case(1)
            ret = point
         case(2)
            ret = line
         case(3:)
            ret = line
            do i = 1, n
               sig = cross_2d(xs(i) - xs(mod1(i - 1, n)), ys(i) - ys(mod1(i - 1, n)), xs(mod1(i + 1, n)) - xs(i), ys(mod1(i + 1, n)) - ys(i))
               select case(ret)
               case(line)
                  if(sig > 0)then
                     ret = left_convex_polygon
                  else if(sig < 0)then
                     ret = right_convex_polygon
                  end if
               case(left_convex_polygon)
                  if(sig < 0)then
                     ret = other
                     return
                  end if
               case(right_convex_polygon)
                  if(sig > 0)then
                     ret = other
                     return
                  end if
               case default
                  RAISE("Must not happen")
               end select
            end do
         end select
      end function shape_of<%= k %>


      pure subroutine distance_and_angles_2d<%= k %>(u, v, d, th_u, th_v)
         Real(kind=real<%= k %>), intent(in):: u(2), v(2)
         Real(kind=real<%= k %>), intent(out):: d ! distance between the origin and line u->v
         Real(kind=real<%= k %>), intent(out):: th_u ! angle from intersection vector to u
         Real(kind=real<%= k %>), intent(out):: th_v ! angle from intersection vector to v

         Real(kind=real<%= k %>):: intersection(2)

         d = distance_2d(u, v) ! todo: norm2(intersection)
         intersection = perpendicular_2d(u, v)
         th_u = angle_2d(intersection, u)
         th_v = angle_2d(intersection, v)
      end subroutine distance_and_angles_2d<%= k %>


      pure function angle_2d<%= k %>(u, v) result(ret)
         ! Return an angle from u to v
         Real(kind=real<%= k %>):: ret
         Real(kind=kind(ret)), intent(in):: u(2), v(2)

         ret = atan2(cross_2d(u, v), dot_product(u, v))
      end function angle_2d<%= k %>


      pure function perpendicular_2d_uv<%= k %>(u, v) result(ret)
         ! Return a intersection point of line u->v and a line ⟂ u->v and passes the origin
         Real(kind=real<%= k %>), parameter:: one = 1
         Real(kind=real<%= k %>):: ret(2)
         Real(kind=kind(ret)), intent(in):: u(2), v(2)
         Real(kind=kind(ret)):: p_uv(2)

         p_uv = perpendicular_2d(v - u)
         ret = sign(one, dot_product(u, p_uv))*distance_2d(u, v)/norm2(p_uv)*p_uv
      end function perpendicular_2d_uv<%= k %>


      pure function perpendicular_2d_v<%= k %>(v) result(ret)
         ! Return a vector ⟂ to v
         Real(kind=real<%= k %>):: ret(2)
         Real(kind=kind(ret)), intent(in):: v(2)

         ret(1) = -v(2)
         ret(2) = v(1)
      end function perpendicular_2d_v<%= k %>


      pure function distance_2d<%= k %>(u, v) result(ret)
         ! Return distance from the origin to a line u->v
         Real(kind=real<%= k %>):: ret
         Real(kind=kind(ret)), intent(in):: u(2), v(2)

         ret = abs(cross_2d(u, v))/norm2(v - u)
      end function distance_2d<%= k %>


      pure function cross_2d_u_v<%= k %>(u, v) result(ret)
         ! Return z component of cross product u × v
         Real(kind=real<%= k %>):: ret
         Real(kind=kind(ret)), intent(in):: u(2), v(2)

         ret = cross_2d(u(1), u(2), v(1), v(2))
      end function cross_2d_u_v<%= k %>


      pure function cross_2d_u1_u2_v1_v2<%= k %>(u1, u2, v1, v2) result(ret)
         ! Return component of cross product (u1, u2) × (v1, v2)
         Real(kind=real<%= k %>):: ret
         Real(kind=kind(ret)), intent(in):: u1, u2, v1, v2

         ret = u1*v2 - u2*v1
      end function cross_2d_u1_u2_v1_v2<%= k %>
   <%- } -%>
end module geometry_lib
