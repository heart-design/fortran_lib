<%
require 'fort'
require './template.rb'

class Context < ContextBase
  def initialize(tree_type_declare, tree_type_id, node_type_declare, node_type_id, key_in_type_declare, key_in_type_id)
    @tree_type_declare = tree_type_declare
    @tree_type_id = tree_type_id
    @node_type_declare = node_type_declare
    @node_type_id = node_type_id
    @key_in_type_declare = key_in_type_declare
    @key_in_type_id = key_in_type_id
  end

  attr_reader :tree_type, :tree_type_id, :node_type, :node_type_id, :key_in_type, :key_in_type_id
end


def allocatable?(s)
   (s.start_with? 'Character') || (s !~ /Dim0/)
end



LOGICALS = ::Fort::Type::Logical.multi_provide(dim: [0])

KEY_TYPES\
= ::Fort::Type::Real.multi_provide(dim: [0])\
+ ::Fort::Type::Integer.multi_provide(dim: [0])\
+ ::Fort::Type::Character.multi_provide(len: :':', dim: [0]) # `0..6` causes ICE for GFortran version 4.9.1

KEY_IN_TYPES\
= ::Fort::Type::Real.multi_provide(dim: [0])\
+ ::Fort::Type::Integer.multi_provide(dim: [0])\
+ ::Fort::Type::Character.multi_provide(len: :'*', dim: [0])

VALUE_TYPES\
= ::Fort::Type::Real.multi_provide\
+ ::Fort::Type::Integer.multi_provide\
+ ::Fort::Type::Complex.multi_provide\
+ ::Fort::Type::Logical.multi_provide\
+ ::Fort::Type::Character.multi_provide(len: [:':'], dim: [0])

VALUE_IN_TYPES\
= ::Fort::Type::Real.multi_provide\
+ ::Fort::Type::Integer.multi_provide\
+ ::Fort::Type::Complex.multi_provide\
+ ::Fort::Type::Logical.multi_provide\
+ ::Fort::Type::Character.multi_provide(len: [:*], dim: [0])

PARAMSS = KEY_TYPES.zip(KEY_IN_TYPES).product(VALUE_TYPES.zip(VALUE_IN_TYPES)).map{|(k, k_in), (v, v_in)|
   {
      tree_type: "#{k}#{v}BinaryTreeMap",
      tree_type_declare: "type(#{k}#{v}BinaryTreeMap)",
      tree_type_id: "#{k.id}#{v.id}BinaryTreeMap",
      node_type: "#{k}#{v}BinaryTreeMapNode",
      node_type_declare: "type(#{k}#{v}BinaryTreeMapNode)",
      node_type_id: "#{k.id}#{v.id}BinaryTreeMapNode",
      key_type: k.to_s,
      key_type_declare: k.declare,
      key_type_id: k.id,
      key_in_type: k_in.to_s,
      key_in_type_declare: k_in.declare,
      key_in_type_id: k_in.id,
      value_type: v.to_s,
      value_type_declare: v.declare,
      value_type_id: v.id,
      value_in_type: v_in.to_s,
      value_in_type_declare: v_in.declare,
      value_in_type_id: v_in.id,
   }
}
%>


# include "fortran_lib.h"
# define KEY(x) x%key
module binary_tree_map_lib
   USE_FORTRAN_LIB_H
   <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
   use, intrinsic:: iso_fortran_env, only: INT8

   implicit none

   private
   public:: put, get, delete


   <% PARAMSS.each{|params| %>
      <%
      key_type = params[:key_type]
      value_type = params[:value_type]
      tree_type = params[:tree_type]
      node_type = params[:node_type]
      node_type_declare = params[:node_type_declare]
      key_type_declare = params[:key_type_declare]
      value_type_declare = params[:value_type_declare]
      is_key_allocatable = allocatable?(key_type)
      is_value_allocatable = allocatable?(value_type)
      %>
      type, public:: <%= node_type %>
         <% if is_key_allocatable %>
            <%= key_type_declare %>, allocatable:: key
         <% else %>
            <%= key_type_declare %>:: key
         <% end %>
         <% if is_value_allocatable %>
            <%= value_type_declare %>, allocatable:: value_
         <% else %>
            <%= value_type_declare %>:: value_
         <% end %>
         <%= node_type_declare %>, pointer:: parent => null()
         <%= node_type_declare %>, pointer:: left => null()
         <%= node_type_declare %>, pointer:: right => null()
      end  type <%= node_type %>


      type, public:: <%= tree_type %>
         <%= node_type_declare %>, pointer:: root => null()
      end  type <%= tree_type %>
   <% } %>


   <% PARAMSS.each{|params| %>
      <%
      tree_type_id = params[:tree_type_id]
      key_in_type_id = params[:key_in_type_id]
      value_in_type_id = params[:value_in_type_id]
      node_type_id = params[:node_type_id]
      %>
      interface put
         module procedure put<%= tree_type_id %><%= key_in_type_id %><%= value_in_type_id %>
      end interface put

      interface get
         module procedure get<%= tree_type_id %><%= key_in_type_id %>
         <% LOGICALS.each{|l| %>
            module procedure get<%= tree_type_id %><%= key_in_type_id %><%= l.id %>
         <% } %>
      end interface get

      interface delete
         module procedure delete<%= tree_type_id %><%= key_in_type_id %>
         module procedure delete<%= node_type_id %>
      end interface delete
   <% } %>


contains

   
   <% PARAMSS.each{|params| %>
      <%
      value_type = params[:value_type]
      tree_type_id = params[:tree_type_id]
      key_in_type_id = params[:key_in_type_id]
      value_in_type_id = params[:value_in_type_id]
      node_type_id = params[:node_type_id]
      tree_type_declare = params[:tree_type_declare]
      key_in_type_declare = params[:key_in_type_declare]
      value_in_type_declare = params[:value_in_type_declare]
      node_type_declare = params[:node_type_declare]
      value_type_declare = params[:value_type_declare]
      key_type_declare = params[:key_type_declare]
      key_type_id = params[:key_type_id]
      key_type = params[:key_type]
      is_key_allocatable = allocatable?(key_type)
      is_value_allocatable = allocatable?(value_type)
      %>


      pure subroutine put<%= tree_type_id %><%= key_in_type_id %><%= value_in_type_id %>(tree, key, value_)
         <%= tree_type_declare %>, intent(inout):: tree
         <%= key_in_type_declare %>, intent(in):: key
         <%= value_in_type_declare %>, intent(in):: value_
         <%= node_type_declare %>, pointer:: new_node

         allocate(new_node)
         KEY(new_node) = key
         new_node%value_ = value_
         call put<%= tree_type_id %><%= node_type_id %>(tree, new_node)
      end subroutine put<%= tree_type_id %><%= key_in_type_id %><%= value_in_type_id %>


      function get<%= tree_type_id %><%= key_in_type_id %>(tree, key) result(value_)
         <%= tree_type_declare %>, intent(in):: tree
         <%= key_in_type_declare %>, intent(in):: key
         <% if is_value_allocatable %>
            <%= value_type_declare %>, allocatable:: value_
         <% else %>
            <%= value_type_declare %>:: value_
         <% end %>
         Logical(kind=INT8):: found

         value_ = get(tree, key, found)
         ASSERT(found)
      end function get<%= tree_type_id %><%= key_in_type_id %>


      <% LOGICALS.each{|l| %>
         function get<%= tree_type_id %><%= key_in_type_id %><%= l.id %>(tree, key, found) result(value_)
            <%= tree_type_declare %>, intent(in):: tree
            <%= key_in_type_declare %>, intent(in):: key
            <%= l.declare %>, intent(out):: found
            <% if is_value_allocatable %>
               <%= value_type_declare %>, allocatable:: value_
            <% else %>
               <%= value_type_declare %>:: value_
            <% end %>
            <%= node_type_declare %>, pointer:: node

            node => get_impl<%= node_type_id %><%= key_in_type_id %>(tree%root, key)
            found = associated(node)
            if(found)then
               value_ = node%value_
            end if
         end function get<%= tree_type_id %><%= key_in_type_id %><%= l.id %>
      <% } %>


      subroutine delete<%= tree_type_id %><%= key_in_type_id %>(tree, key)
         <%= tree_type_declare %>, intent(inout):: tree
         <%= key_in_type_declare %>, intent(in):: key
         <%= node_type_declare %>, pointer:: node

         node => get_impl<%= node_type_id %><%= key_in_type_id %>(tree%root, key)
         if(associated(node))then
            call delete<%= tree_type_id %><%= node_type_id %>(tree, node)
         end if
      end subroutine delete<%= tree_type_id %><%= key_in_type_id %>


      pure subroutine delete<%= node_type_id %>(node)
         <%= node_type_declare %>, pointer, intent(inout):: node

         if(associated(node))then
            <% if is_key_allocatable %>
               if(allocated(KEY(node))) deallocate(KEY(node))
            <% end %>
            <% if  is_value_allocatable %>
               if(allocated(node%value_)) deallocate(node%value_)
            <% end %>
            deallocate(node)
            node => null()
         end if
      end subroutine delete<%= node_type_id %>


      <%= Context.new(tree_type_declare, tree_type_id, node_type_declare, node_type_id, key_in_type_declare, key_in_type_id).render(memoized_read("binary_tree_template.f90.erb")) %>
   <% } %>
end module binary_tree_map_lib
