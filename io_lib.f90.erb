<%
  require 'fort'

  TYPES\
  = ::Fort::Type::Logical.multi_provide(dim: (1..7))\
  + ::Fort::Type::Integer.multi_provide(dim: (1..7))\
  + ::Fort::Type::Real.multi_provide(dim: (1..7))\
  + ::Fort::Type::Complex.multi_provide(dim: (1..7))\
  + ::Fort::Type::Character.multi_provide(dim: (1..7))

  LOGICAL_DIM_0S = ::Fort::Type::Logical.multi_provide(dim: 0)
  INTEGER_DIM_0S = ::Fort::Type::Integer.multi_provide(dim: 0)
  REAL_DIM_0S = ::Fort::Type::Real.multi_provide(dim: 0)
  COMPLEX_DIM_0S = ::Fort::Type::Complex.multi_provide(dim: 0)

  def list(n, joint = ', ', &block)
    (1..n).to_a.map(&block).join(joint)
  end

  NUM_DESC_MAX = 10
  LEN_TYPE_STR_MAX = TYPES.map(&:to_s).map(&:size).max
%>

#include "fortran_lib.h"
module io_lib
   USE_FORTRAN_LIB_H
   use, intrinsic:: iso_fortran_env, only: error_unit, input_unit, output_unit
   use, intrinsic:: iso_fortran_env, only: int64
   <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
# ifdef __INTEL_COMPILER
   use, non_intrinsic:: ifport, only: system
# endif
   use, non_intrinsic:: constant_lib, only: TAB
   use, non_intrinsic:: character_lib, only: s, str, operator(+)
   use, non_intrinsic:: config_lib, only: get_config_value

   implicit none

   private
   public:: get_column_format_string
   public:: dump, load, load_version, load_meta
   public:: get_line_number, number_of_columns, file_shape
   public:: mktemp
   public:: sh

   Integer, parameter, public:: version = 2 ! Array file format's compatibility.
   Integer, parameter:: len_data_type_str_max = <%= LEN_TYPE_STR_MAX %>
   Character(len=*), parameter, public:: array_data_file = 'data.bin'
   Character(len=*), parameter:: array_meta_file_v_1 = 'meta.nml'
   Character(len=*), parameter:: array_meta_file_v_2 = 'meta.kv'
   Character(len=*), parameter, public:: array_meta_file = array_meta_file_v_2
   Character(len=*), parameter, public:: array_version_file = 'version.dat'
   Character(len=*), parameter, public:: array_description_file = 'description.txt'

   type, public:: ArrayMeta
      Character(len=len_data_type_str_max):: dataType
      Integer:: dim
      Integer, allocatable:: sizes(:)
   end type ArrayMeta

   <%- (LOGICAL_DIM_0S + INTEGER_DIM_0S + REAL_DIM_0S + COMPLEX_DIM_0S).product(INTEGER_DIM_0S).each{|t, tn| -%>
      interface get_column_format_string
         module procedure get_column_format_string<%= t.id %><%= tn.id %>
      end interface get_column_format_string
   <%- } -%>

   interface load_meta
      module procedure load_array_meta
   end interface load_meta

   interface load_version
      module procedure load_array_version
   end interface load_version

   <%- TYPES.each{|t| -%>
      interface dump
         module procedure dump_array<%= t %>
      end interface dump

      interface load
         module procedure load_array<%= t %>
      end interface load

      interface load_v_2
         module procedure load_array_v_2<%= t %>
      end interface load_v_2

      interface load_v_1
         module procedure load_array_v_1<%= t %>
      end interface load_v_1
   <%- } -%>

contains

   <%- INTEGER_DIM_0S.each{|tn| -%>
      <%- (LOGICAL_DIM_0S + INTEGER_DIM_0S + REAL_DIM_0S).each{|t| -%>
         function get_column_format_string<%= t.id %><%= tn.id %>(x, n) result(ret)
            Character(len=*), parameter:: multi_args = '(g0, *(" ", g0))'
            <%= t.declare %>, intent(in):: x
            <%= tn.declare %>, intent(in):: n
            Character(len=len(multi_args)):: ret

            select case(n)
            case(:0)
               ret = '()'
            case(1)
               ret = '(g0)'
            case(2:)
               ret = multi_args
            end select
         end function get_column_format_string<%= t.id %><%= tn.id %>
      <%- } -%>

      ! `get_column_format_string` is used to produce re-readable complex output.
      ! number of columns should explicitly be given since unlimited format gives an extra parenthesis ` (` at the end.
      <%- COMPLEX_DIM_0S.each{|t| -%>
         function get_column_format_string<%= t.id %><%= tn.id %>(x, n) result(ret)
            Character(len=*), parameter:: multi_args = '("(", g0, ", ", g0, ")", *(" ", "(", g0, ", ", g0, ")"))'
            <%= t.declare %>, intent(in):: x
            <%= tn.declare %>, intent(in):: n
            Character(len=len(multi_args)):: ret

            select case(n)
            case(:0)
               ret = '()'
            case(1)
               ret = '("(", g0, ", ", g0, ")")'
            case(2:)
               ret = multi_args
            end select
         end function get_column_format_string<%= t.id %><%= tn.id %>
      <%- } -%>
   <%- } -%>

   function sh(cmd) result(isSuccess)
      Character(len=*), intent(in):: cmd
      Logical:: isSuccess
      Integer:: exitStatus

# ifdef __INTEL_COMPILER
      exitStatus = system(trim(cmd))
# else
      call execute_command_line(trim(cmd), exitstat = exitStatus)
# endif

      isSuccess = (exitStatus == 0)
   end function sh

   subroutine mktemp(unit, suffixMin, form, file, suffix)
      Character(len=*), parameter:: PREFIX = '/tmp/io_lib_mktemp.'

      Integer, intent(out):: unit
      Integer(kind = INT64), intent(in), optional:: suffixMin
      Character(len=*), intent(in), optional:: form
      Character(len=*), intent(out), optional:: file
      Integer(kind = kind(suffixMin)), intent(out), optional:: suffix

      Integer(kind = kind(suffixMin)):: suffix_, suffixMin_
      Integer:: ios
      Character(len = len(PREFIX) + ceiling(log10(real(huge(suffix_))))):: file_
      Character(len = max(len('unformatted'), len('formatted'))):: form_

      form_ = 'formatted'
      if(present(form))then
         ASSERT(form == 'formatted' .or. form == 'unformatted')
         form_ = form
      end if

      suffixMin_ = 0
      if(present(suffixMin)) suffixMin_ = suffixMin
      do suffix_ = suffixMin_, huge(suffix)
         file_ = PREFIX + str(suffix_)
         open(newunit=unit, file=trim(file_), status='new', action='readwrite', form=trim(form_), iostat=ios)
         if(ios == 0)then
            ASSERT(sh('chmod og-rwx ' + trim(file_)))

            if(present(file))then
               ASSERT(len_trim(file_) <= len(file))
               file = file_
            end if
            if(present(suffix)) suffix = suffix_

            return
         end if
      end do

      RAISE('Could not create temp file')
   end subroutine mktemp

   ! @desc Return a size 2 array which contains (/numberOfLines, numberOfColumns/) of the file fileName.
   function file_shape(fileName, numberOfHeaders) result(answer)
      Integer(int64):: answer(1:2)
      Character(len=*), intent(in):: fileName
      Integer, intent(in), optional:: numberOfHeaders

      Integer:: numberOfHeaders_

      numberOfHeaders_ = 0
      if(present(numberOfHeaders)) numberOfHeaders_ = numberOfHeaders

      answer = (/get_line_number(fileName) - numberOfHeaders_, number_of_columns(fileName, numberOfHeaders_)/)
   end function file_shape

   function get_line_number(path) result(ret)
      Integer(kind=INT64):: ret
      Character(len=*), intent(in):: path

      Integer:: unit, ios
      Character:: trash

      open(newunit=unit, file=path, status='old', action='read')
      ret = 0
      do
         read(unit, *, iostat=ios) trash
         if(ios /= 0) exit
         ASSERT(ret < huge(ret))

         ret = ret + 1
      end do
      close(unit)
   end function get_line_number

   ! @desc Return number of columns at line (numberOfHeaders + 1) in file fileName.
   ! @desc The line is separated by space and tabs character.
   ! @desc Quoted string containing space/tab characteres is not considared.
   function number_of_columns(file, numberOfHeaders) result(answer)
      Integer(int64):: answer
      Character(len=*), intent(in):: file
      Integer, intent(in), optional:: numberOfHeaders

      enum, bind(c)
         enumerator:: SEEK_NORMAL_CHAR, SEEK_SEPARATOR
      end enum
      Character, parameter:: SEPARATORS(1:2) = [' ', TAB]

      Integer:: unit, ios, i, mode
      Character:: c

      Integer:: numberOfHeaders_

      numberOfHeaders_ = 0
      if(present(numberOfHeaders)) numberOfHeaders_ = numberOfHeaders

      mode = SEEK_NORMAL_CHAR
      answer = 0
      open(newunit=unit, file=file, status='old', action='read')
      do i = 1, numberOfHeaders_
         read(unit, *)
      end do
      do
         read(unit, '(a1)', advance='no', iostat=ios) c
         if(is_iostat_bad(ios) .or. c == new_line('_')) exit

         select case(mode)
         case(SEEK_SEPARATOR)
            if(has_val(SEPARATORS, c)) mode = SEEK_NORMAL_CHAR
         case(SEEK_NORMAL_CHAR)
            if(.not.has_val(SEPARATORS, c))then
               ASSERT(answer <= huge(answer) - 1)

               answer = answer + 1
               mode = SEEK_SEPARATOR
            end if
         end select
      end do
      close(unit)
   end function number_of_columns

   function load_array_version(dir) result(version_)
      Character(len=*), intent(in):: dir
      Integer:: version_
      Integer:: unit

      open(newunit=unit, file=s(dir) + '/' + array_version_file, status='old', action='read')
      read(unit, *) version_
      close(unit)
   end function load_array_version

   subroutine load_array_meta(self, dir)
      type(ArrayMeta), intent(inout):: self
      Character(len=*), intent(in):: dir
      Integer:: version_

      version_ = load_array_version(trim(dir))
      select case(version_)
      case(2)
         call load_array_meta_v_2(self, trim(dir))
      case default
         RAISE('Unsupported version ' + str(version_) + ' for ' + trim(dir))
      end select
   end subroutine load_array_meta

   subroutine load_array_meta_v_2(self, dir)
      type(ArrayMeta), intent(inout):: self
      Character(len=*), intent(in):: dir

      Integer:: unit
      Integer:: dim

      open(newunit=unit, file=s(dir) + '/' + array_meta_file_v_2, status='old', action='read')
      ASSERT(get_config_value(unit, 'dataType', self%dataType))
      ASSERT(get_config_value(unit, 'dim', self%dim))
      if(allocated(self%sizes)) deallocate(self%sizes)
      allocate(self%sizes(1:self%dim))
      do ALL_OF(dim, self%sizes, 1)
         ASSERT(get_config_value(unit, 'sizes(' + str(dim) + ')', self%sizes(dim)))
      end do
      close(unit)
   end subroutine load_array_meta_v_2

   <%- TYPES.each{|t| -%>
      subroutine dump_array<%= t %>(self, dir<%= list(NUM_DESC_MAX, ''){|i| ", desc#{i}"} %>)
         <%= t.declare %>, intent(in):: self
         Character(len=*), intent(in):: dir
         <%- if NUM_DESC_MAX >= 1 -%>
            Character(len=*), intent(in), optional:: <%= list(NUM_DESC_MAX){|i| "desc#{i}"} %>
         <%- end -%>

         Character(len=*), parameter:: DATA_TYPE_FOR_SELF = '<%= t %>'
         Integer, parameter:: dim_for_self = <%= t.dim %>

         Character(len=len(DATA_TYPE_FOR_SELF)) dataType
         Integer:: dim
         Integer:: sizes(1:dim_for_self)
         Integer:: unit

         ASSERT(sh('mkdir -p ' + trim(dir)))

         open(newunit=unit, file=s(dir) + '/' + array_version_file, status='replace', action='write')
         write(unit, *) VERSION
         close(unit)

         open(newunit=unit, file=s(dir) + '/' + array_data_file, status='replace', action='write', form='unformatted', access='stream')
         write(unit) self
         close(unit)

         dataType = DATA_TYPE_FOR_SELF
         dim = dim_for_self
         sizes = shape(self)
         open(newunit=unit, file=s(dir) + '/' + ARRAY_META_FILE, status='replace', action='write')
         WRITE_KEY_VALUE(unit, dim)
         WRITE_KEY_VALUE(unit, dataType)
         <%- t.dim.times.each{|dim| -%>
           WRITE_KEY_VALUE(unit, sizes(<%= dim + 1 %>))
         <%- } -%>
         close(unit)


         open(newunit=unit, file=s(dir) + '/' + ARRAY_DESCRIPTION_FILE, status='replace', action='write')
         <%- (1..NUM_DESC_MAX).each{|i| -%>
            if(present(desc<%= i %>)) write(unit, *) desc<%= i %>
         <%- } -%>
         close(unit)
      end subroutine dump_array<%= t %>

      subroutine load_array<%= t %>(self, dir)
         <%= t.declare %>, intent(inout), allocatable:: self
         Character(len=*), intent(in):: dir

         Integer:: version_

         version_ = load_array_version(trim(dir))
         select case(version_)
         case(1)
            call load_v_1(self, dir)
         case(2)
            call load_v_2(self, dir)
         case default
            RAISE('Unsupported version ' + str(version_) + ' for ' + trim(dir))
         end select
      end subroutine load_array<%= t %>

      subroutine load_array_v_2<%= t %>(self, dir)
         <%= t.declare %>, intent(inout), allocatable:: self
         Character(len=*), intent(in):: dir

         Character(len=*), parameter:: DATA_TYPE_FOR_SELF = '<%= t %>'
         Integer, parameter:: dim_for_self = <%= t.dim %>
         type(ArrayMeta):: meta
         Integer:: unit

         call load_array_meta_v_2(meta, trim(dir))

         ASSERT(meta%dataType == DATA_TYPE_FOR_SELF)
         ASSERT(meta%dim == dim_for_self)

         if(allocated(self)) deallocate(self)
         allocate(self(<%= list(t.dim){|i| "1:meta%sizes(#{i})"} %>))

         open(newunit=unit, file=s(dir) + '/' + array_data_file, status='old', action='read', form='unformatted', access='stream')
         read(unit) self
      end subroutine load_array_v_2<%= t %>

      subroutine load_array_v_1<%= t %>(self, dir)
         <%= t.declare %>, intent(inout), allocatable:: self
         Character(len=*), intent(in):: dir

         Character(len=*), parameter:: data_type_for_self = '<%= t %>'
         Integer, parameter:: dim_for_self = <%= t.dim %>
         Character(len=<%= TYPES.map{|_| _.to_s.size}.max %>):: dataType
         Integer:: dim
         Integer:: sizes(1:dim_for_self)
         Integer:: unit
         namelist /array_meta/ dataType, dim, sizes

         open(newunit=unit, file=s(dir) + '/' + array_meta_file_v_1, status='old', action='read', delim='quote')
         read(unit, nml=array_meta)

         ASSERT(s(dataType) == data_type_for_self)
         ASSERT(dim == dim_for_self)

         close(unit)

         if(allocated(self)) deallocate(self)
         allocate(self(<%= list(t.dim){|i| "1:sizes(#{i})"} %>))

         open(newunit=unit, file=s(dir) + '/' + array_data_file, status='old', action='read', form='unformatted', access='stream')
         read(unit) self
      end subroutine load_array_v_1<%= t %>
   <%- } -%>
end module io_lib
