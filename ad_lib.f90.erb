<%-
  RKINDS = [
    32,
    64,
    128,
  ]
  IKINDS = [
    8,
    16,
    32,
    64,
  ]
  ORDERS = [
    1,
    2,
  ]
  NS = [
    1,
    2,
    5,
  ]
  RKINDS_ORDERS_NS = RKINDS.product(ORDERS, NS)
  FN1S = [
    :exp,
    :log,
  ]
  OPS = {
    add: :+,
    sub: :-,
    mul: :*,
    div: :/,
    pow: :**,
  }
  COMPS = {
    lt: :<,
    le: :<=,
    eq: :==,
    ge: :>=,
    gt: :>,
  }
-%>
#include "fortran_lib.h"

! todo: optimize
#define mul_g() (x%g*y%f + x%f*y%g)
#define mul_h_ij(i, j) (x%h(i, j)*y%f + x%g(i)*y%g(j) + x%g(j)*y%g(i) + x%f*y%h(i, j))
#define div_h_ij(i, j) (((x%h(i, j)*yf - y%h(i, j)*xf - y%g(i)*x%g(j))*yf - y%g(j)*(x%g(i)*yf - 2*y%g(i)*xf))*par_yf3)
#define f_h_ij(f1, f2, i, j) ((f2(x%f))*x%g(i)*x%g(j) + (f1(x%f))*x%h(i, j))
#define exp_p1(x) (exp(x))
#define exp_p2(x) (exp(x))
#define log_p1(x) (1/(x))
#define log_p2(x) (-1/(x)**2)

module ad_lib
   <%- RKINDS.each{|k|-%>
      use, intrinsic:: iso_fortran_env, only: real<%= k %>
   <%- } -%>
   <%- IKINDS.each{|k|-%>
      use, intrinsic:: iso_fortran_env, only: int<%= k %>
   <%- } -%>
   USE_FORTRAN_LIB_H
   use, intrinsic:: iso_fortran_env, only: input_unit, output_unit, error_unit

   implicit none

   private
   ! accessors
   public:: kind, real, jaco, hess
   public:: epsilon, tiny, huge
   ! functions
   public:: dot_product
   public:: sum
   <%- FN1S.each{|fn| -%>
      public:: <%= fn %>
   <%- } -%>
   ! operators
   <%- (OPS.merge(COMPS)).each{|_, op| -%>
      public:: operator(<%= op %>)
   <%- } -%>

   type, public:: DualNumber
   end type DualNumber

   <%- RKINDS_ORDERS_NS.each{|kd, o, n| -%>
      type, extends(DualNumber), public:: Dual<%= kd %>_<%= o %>_<%= n %>
         Real(kind=real<%= kd %>):: f = 0
         Real(kind=real<%= kd %>):: g(<%= n %>) = 0
         <%- if o > 1 -%>
            Real(kind=real<%= kd %>):: h(<%= n %>, <%= n %>) = 0
         <%- end -%>
      end type Dual<%= kd %>_<%= o %>_<%= n %>
   <%- } -%>

   ! Interface
   <%- RKINDS_ORDERS_NS.each{|kd, o, n| -%>
      interface kind
         module procedure kind_<%= kd %>_<%= o %>_<%= n %>
      end interface kind

      interface real
         module procedure real_<%= kd %>_<%= o %>_<%= n %>
      end interface real

      interface jaco
         module procedure jaco_<%= kd %>_<%= o %>_<%= n %>
      end interface jaco

      <%- [:epsilon, :tiny, :huge].each{|fn1| -%>
         interface <%= fn1 %>
            module procedure <%= fn1 %>_<%= kd %>_<%= o %>_<%= n %>
         end interface <%= fn1 %>
      <%- } -%>

      <%- if o > 1 -%>
         interface hess
            module procedure hess_<%= kd %>_<%= o %>_<%= n %>
         end interface hess
      <%- end -%>

      <% RKINDS.each{|kd2| %>
         interface dot_product
            module procedure dot_product_dd_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>
            module procedure dot_product_dr_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>
            module procedure dot_product_rd_<%= kd2 %>_<%= kd %>_<%= o %>_<%= n %>
         end interface dot_product
      <% } %>

      interface sum
         module procedure sum_<%= kd %>_<%= o %>_<%= n %>_1
      end interface sum

      <%- FN1S.each{|fn1| -%>
         interface <%= fn1 %>
            module procedure <%= fn1 %>_<%= kd %>_<%= o %>_<%= n %>
         end interface <%= fn1 %>
      <%- } -%>

      interface operator(-)
         module procedure neg_<%= kd %>_<%= o %>_<%= n %>
      end interface operator(-)

      <%- (OPS.merge(COMPS)).each{|fn2, op| -%>
         <%- RKINDS.each{|kdr| -%>
            interface operator(<%= op %>)
               module procedure <%= fn2 %>_dd_<%= kd %>_<%= kdr %>_<%= o %>_<%= n %>

               module procedure <%= fn2 %>_dr_<%= kd %>_<%= kdr %>_<%= o %>_<%= n %>
               module procedure <%= fn2 %>_rd_<%= kdr %>_<%= kd %>_<%= o %>_<%= n %>
            end interface operator(<%= op %>)
         <%- } -%>

         <%- IKINDS.each{|ki| -%>
            interface operator(<%= op %>)
               module procedure <%= fn2 %>_di_<%= kd %>_<%= ki %>_<%= o %>_<%= n %>
               module procedure <%= fn2 %>_id_<%= ki %>_<%= kd %>_<%= o %>_<%= n %>
            end interface operator(<%= op %>)
         <%- } -%>
      <%- } -%>
   <%- } -%>

contains

   <%- RKINDS_ORDERS_NS.each{|kd, o, n| -%>
      elemental function kind_<%= kd %>_<%= o %>_<%= n %>(x) result(ret)
         type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
         Integer:: ret

         ret = <%= kd %>
      end function kind_<%= kd %>_<%= o %>_<%= n %>

      <%- [:epsilon, :tiny, :huge].each{|fn1| -%>
         elemental function <%= fn1 %>_<%= kd %>_<%= o %>_<%= n %>(x) result(ret)
            type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
            Real(kind=real<%= kd %>):: ret

            ret = <%= fn1 %>(ret)
         end function <%= fn1 %>_<%= kd %>_<%= o %>_<%= n %>
      <%- } -%>

      elemental function real_<%= kd %>_<%= o %>_<%= n %>(x) result(ret)
         type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
         Real(kind=real<%= kd %>):: ret

         ret = x%f
      end function real_<%= kd %>_<%= o %>_<%= n %>

      pure function jaco_<%= kd %>_<%= o %>_<%= n %>(x) result(ret)
         type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
         Real(kind=real<%= kd %>):: ret(<%= n %>)

         ret = x%g
      end function jaco_<%= kd %>_<%= o %>_<%= n %>

      <%- if o > 1 -%>
         pure function hess_<%= kd %>_<%= o %>_<%= n %>(x) result(ret)
            type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
            Real(kind=real<%= kd %>):: ret(<%= n %>, <%= n %>)
            Integer:: i, j

            do j = 1, <%= n %>
               ret(j, j) = x%h(j, j)
               do i = j + 1, <%= n %>
                  ret(i, j) = x%h(i, j)
                  ret(j, i) = x%h(i, j)
               end do
            end do
         end function hess_<%= kd %>_<%= o %>_<%= n %>
      <%- end -%>

      <%- RKINDS.each{|kd2| -%>
         pure function dot_product_dd_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>(x, y) result(z)
            type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x(:)
            type(Dual<%= kd2 %>_<%= o %>_<%= n %>), intent(in):: y(size(x))
            type(Dual<%= [kd, kd2].max %>_<%= o %>_<%= n %>):: z

            z = sum(x*y)
         end function dot_product_dd_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>
      <%- } -%>

      <%- RKINDS.each{|kr| -%>
         <%-
            t = :r
            t_decl = "Real(kind=real#{kr})"
            k_ret = [kd, kr].max
            d_r = "dot_product_d#{t}_#{kd}_#{kr}_#{o}_#{n}"
            r_d = "dot_product_#{t}d_#{kr}_#{kd}_#{o}_#{n}"
         -%>
         pure function <%= d_r %>(x, y) result(z)
            type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x(:)
            <%= t_decl %>, intent(in):: y(size(x))
            type(Dual<%= k_ret %>_<%= o %>_<%= n %>):: z

            z = sum(x*y)
         end function <%= d_r %>

         pure function <%= r_d %>(x, y) result(z)
            <%= t_decl %>, intent(in):: x(:)
            type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: y(size(x))
            type(Dual<%= k_ret %>_<%= o %>_<%= n %>):: z

            z = sum(x*y)
         end function <%= r_d %>
      <%- } -%>

      pure function sum_<%= kd %>_<%= o %>_<%= n %>_1(x) result(y)
         Integer(kind=int64), parameter:: one = 1
         type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x(:)
         type(Dual<%= kd %>_<%= o %>_<%= n %>):: y

         y = sum_pairwise_<%= kd %>_<%= o %>_<%= n %>_1(x, one, size(x, kind=kind(one)))
      end function sum_<%= kd %>_<%= o %>_<%= n %>_1

      pure recursive function sum_pairwise_<%= kd %>_<%= o %>_<%= n %>_1(x, i1, i2) result(y)
         Integer(kind=int32), parameter:: blocksize = 2**5
         type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x(:)
         Integer(kind=int64), intent(in):: i1, i2
         type(Dual<%= kd %>_<%= o %>_<%= n %>):: y
         Integer(kind=kind(i1)):: i_mid

         if(i1 + blocksize > i2)then
            y = sum_seq_<%= kd %>_<%= o %>_<%= n %>_1(x, i1, i2)
         else
            i_mid = (i1 + i2)/2
            y &
               = sum_pairwise_<%= kd %>_<%= o %>_<%= n %>_1(x, i1, i_mid) &
               + sum_pairwise_<%= kd %>_<%= o %>_<%= n %>_1(x, i_mid + 1, i2)
         end if
      end function sum_pairwise_<%= kd %>_<%= o %>_<%= n %>_1

      pure function sum_seq_<%= kd %>_<%= o %>_<%= n %>_1(x, i1, i2) result(y)
         type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x(:)
         Integer(kind=int64), intent(in):: i1, i2
         type(Dual<%= kd %>_<%= o %>_<%= n %>):: y
         Integer(kind=kind(i1)):: i

         do i = i1, i2
            y = y + x(i)
         end do
      end function sum_seq_<%= kd %>_<%= o %>_<%= n %>_1

      <%- FN1S.each{|fn1| -%>
         elemental function <%= fn1 %>_<%= kd %>_<%= o %>_<%= n %>(x) result(y)
            type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
            type(Dual<%= kd %>_<%= o %>_<%= n %>):: y
            <%- if o > 1 -%>
               Integer:: i, j
            <%- end -%>

            y%f = <%= fn1 %>(x%f)
            y%g = <%= fn1 %>_p1(x%f)*x%g
            <%- if o > 1 -%>
               do j = 1, <%= n %>
                  y%h(j, j) = f_h_ij(<%= fn1 %>_p1, <%= fn1 %>_p2, j, j)
                  do i = j + 1, <%= n %>
                     y%h(i, j) = f_h_ij(<%= fn1 %>_p1, <%= fn1 %>_p2, i, j)
                  end do
               end do
            <%- end -%>
         end function <%= fn1 %>_<%= kd %>_<%= o %>_<%= n %>
      <%- } -%>

      elemental function neg_<%= kd %>_<%= o %>_<%= n %>(x) result(y)
         type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
         type(Dual<%= kd %>_<%= o %>_<%= n %>):: y

         y%f = -x%f
         y%g = -x%g
         <%- if o > 1 -%>
            y%h = -x%h
         <%- end -%>
      end function neg_<%= kd %>_<%= o %>_<%= n %>

      <%- RKINDS.each{|kd2| -%>
         <%- suffix = "_dd_#{kd}_#{kd2}_#{o}_#{n}"-%>

         <%- [:add, :sub].each{|fn2| -%>
            <%- op = OPS[fn2] -%>
            elemental function <%= fn2 %><%= suffix %>(x, y) result(z)
               type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
               type(Dual<%= kd2 %>_<%= o %>_<%= n %>), intent(in):: y
               type(Dual<%= [kd, kd2].max %>_<%= o %>_<%= n %>):: z

               z%f = x%f <%= op %> y%f
               z%g = x%g <%= op %> y%g
               <%- if o > 1 -%>
                  z%h = x%h <%= op %> y%h
               <%- end -%>
            end function <%= fn2 %><%= suffix %>
         <%- } -%>

         <%- [:mul].each{|fn2| -%>
            <%- op = OPS[fn2] -%>
            elemental function <%= fn2 %><%= suffix %>(x, y) result(z)
               type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
               type(Dual<%= kd2 %>_<%= o %>_<%= n %>), intent(in):: y
               type(Dual<%= [kd, kd2].max %>_<%= o %>_<%= n %>):: z
               <%- if o > 1 -%>
                  Integer:: i, j
               <%- end -%>

               z%f = x%f <%= op %> y%f
               z%g = <%= fn2 %>_g()
               <%- if o > 1 -%>
                  do j = 1, <%= n %>
                     z%h(j, j) = <%= fn2 %>_h_ij(j, j)
                     do i = j + 1, <%= n %>
                        z%h(i, j) = <%= fn2 %>_h_ij(i, j)
                     end do
                  end do
               <%- end -%>
            end function <%= fn2 %><%= suffix %>
         <%- } -%>

         elemental function div_dd_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>(x, y) result(z)
            type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
            type(Dual<%= kd2 %>_<%= o %>_<%= n %>), intent(in):: y
            type(Dual<%= [kd, kd2].max %>_<%= o %>_<%= n %>):: z
            Real(kind=real<%= [kd, kd2].max %>):: xf, yf, par_yf3
            <%- if o > 1 -%>
               Integer:: i, j
            <%- end -%>


            xf = x%f
            yf = y%f
            par_yf3 = 1/yf**3

            z%f = xf/yf
            z%g = (x%g*yf - xf*y%g)/yf**2
            <%- if o > 1 -%>
               do j = 1, <%= n %>
                  z%h(j, j) = div_h_ij(j, j)
                  do i = j + 1, <%= n %>
                     z%h(i, j) = div_h_ij(i, j)
                  end do
               end do
            <%- end -%>
         end function div_dd_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>

         elemental function pow_dd_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>(x, y) result(z)
            type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
            type(Dual<%= kd2 %>_<%= o %>_<%= n %>), intent(in):: y
            type(Dual<%= [kd, kd2].max %>_<%= o %>_<%= n %>):: z
            Real(kind=real<%= [kd, kd2].max %>):: xf, yf, x_pow_y, log_x, y_par_x
            <%- if o > 1 -%>
               Real(kind=real<%= [kd, kd2].max %>):: yj_logx_y_xj_par_x, xj, xj_par_x, yj_par_x
               Integer:: i, j
            <%- end -%>


            xf = x%f
            yf = y%f
            x_pow_y = xf**yf
            log_x = log(xf)
            y_par_x = yf/xf

            z%f = x_pow_y
            z%g = (y%g*log_x + x%g*y_par_x)*x_pow_y
            <%- if o > 1 -%>
               z%h = (x%h*y_par_x + y%h*log_x)*x_pow_y
               do, concurrent(j = 1:<%= n%>)
                  xj = x%g(j)
                  xj_par_x = xj/xf
                  yj_par_x = y%g(j)/xf
                  yj_logx_y_xj_par_x = y%g(j)*log_x + y_par_x*x%g(j)
                  do, concurrent(i = j:<%= n %>)
                     z%h(i, j) = z%h(i, j) + (x%g(i)*(yj_par_x - y_par_x*xj_par_x + y_par_x*yj_logx_y_xj_par_x) + y%g(i)*(xj_par_x + log_x*yj_logx_y_xj_par_x))*x_pow_y
                  end do
               end do
            <%- end -%>
         end function pow_dd_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>
      <%- } -%>

      ! todo: optimize for integers
      <%- OPS.each{|fn2, op| -%>
         <%- [:r, :i].each{|t| -%>
            <%- (t == :r ? RKINDS : IKINDS).each{|kri| -%>
               <%-
                 t_decl = t == :r ? "Real(kind=real#{kri})" : "Integer(kind=int#{kri})"
                 # this promotion rule emulates Fortran
                 k_ret = t == :r ? [kd, kri].max : kd
                 d_ri = "#{fn2}_d#{t}_#{kd}_#{kri}_#{o}_#{n}"
                 ri_d = "#{fn2}_#{t}d_#{kri}_#{kd}_#{o}_#{n}"
               -%>
               elemental function <%= d_ri %>(x, y) result(z)
                  type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
                  <%= t_decl %>, intent(in):: y
                  type(Dual<%= k_ret %>_<%= o %>_<%= n %>):: z

                  z = x <%= op %> Dual<%= k_ret %>_<%= o %>_<%= n %>(y)
               end function <%= d_ri %>

               elemental function <%= ri_d %>(x, y) result(z)
                  <%= t_decl %>, intent(in):: x
                  type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: y
                  type(Dual<%= k_ret %>_<%= o %>_<%= n %>):: z

                  z = Dual<%= k_ret %>_<%= o %>_<%= n %>(x) <%= op %> y
               end function <%= ri_d %>
            <%- } -%>
         <%- } -%>
      <%- } -%>

      <%- COMPS.each{|fn2, op| -%>
         <%- RKINDS.each{|kd2| -%>
            elemental function <%= fn2 %>_dd_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>(x, y) result(ret)
               type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
               type(Dual<%= kd2 %>_<%= o %>_<%= n %>), intent(in):: y
               Logical:: ret

               ret = x%f <%= op %> y%f
            end function <%= fn2 %>_dd_<%= kd %>_<%= kd2 %>_<%= o %>_<%= n %>
         <%- } -%>

         <%- [:r, :i].each{|t| -%>
            <%- (t == :r ? RKINDS : IKINDS).each{|kri| -%>
               <%-
                 t_decl = t == :r ? "Real(kind=real#{kri})" : "Integer(kind=int#{kri})"
                 # this promotion rule emulates Fortran
                 d_ri = "#{fn2}_d#{t}_#{kd}_#{kri}_#{o}_#{n}"
                 ri_d = "#{fn2}_#{t}d_#{kri}_#{kd}_#{o}_#{n}"
               -%>
               elemental function <%= d_ri %>(x, y) result(ret)
                  type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: x
                  <%= t_decl %>, intent(in):: y
                  Logical:: ret

                  ret = x%f <%= op %> y
               end function <%= d_ri %>

               elemental function <%= ri_d %>(x, y) result(ret)
                  <%= t_decl %>, intent(in):: x
                  type(Dual<%= kd %>_<%= o %>_<%= n %>), intent(in):: y
                  Logical:: ret

                  ret = x <%= op %> y%f
               end function <%= ri_d %>
            <%- } -%>
         <%- } -%>
      <%- } -%>
   <%- } -%>
end module ad_lib
