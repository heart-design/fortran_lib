<%-
def enlarge(sml_n, scale)
  sml_n\
    .map{|array| array\
      .map{|n| n*scale}}\
    .map{|array| [array, array.sort]}
end

SCALE_UNI = 1
SCALE_I = 2**31 - 1
SCALE_F = 3.402823E+38

SML = [-1, 0, 1]
SML_SETS = [
  SML.product(SML),
  SML.product(SML, SML),
  SML.product(SML, SML, SML),
  SML.product(SML, SML, SML, SML),
]

SORTS = [:quick, :merge, :insertion]
-%>

#include "fortran_lib.h"
program sort_lib_test
   USE_FORTRAN_LIB_H
   use, intrinsic:: iso_fortran_env, only: OUTPUT_UNIT, REAL64, INT64
   use, non_intrinsic:: constant_lib, only: get_infinity
   use, non_intrinsic:: comparable_lib, only: almost_equal
   use, non_intrinsic:: random_lib, only: random_seed_by_time
   use, non_intrinsic:: sort_lib

   implicit none

   Integer:: i
   Integer, allocatable:: seeds(:)
   Integer:: nDArray
   Real(kind = REAL64), allocatable:: dArray(:), sortedDArray(:)
   Integer:: ns(2), ms(2), nsForPartitioning(5) = [3, 4, 2, 1, 1]
   Integer(kind=INT64):: iPivot

   call random_seed_by_time(seeds)
   PRINT_VARIABLE(seeds)

   TEST(almost_equal(median([1, 2, 3, 4]), 2.5))
   TEST(almost_equal(median([1, 2, 3, 4, 5]), 3.0))
   TEST(almost_equal(median([1]), 1.0))

   TEST(select([5, 2, 1, 3, 4], 1) == 1)
   TEST(select([5, 2, 1, 3, 4], 2) == 2)
   TEST(select([5, 2, 1, 3, 4], 3) == 3)
   TEST(select([5, 2, 1, 3, 4], 4) == 4)
   TEST(select([5, 2, 1, 3, 4], 5) == 5)

   call partitioning(nsForPartitioning, 2, iPivot)
   TEST(iPivot == 3)
   nsForPartitioning = [1, 1, 1, 1, 1]
   call partitioning(nsForPartitioning, 1, iPivot)
   nsForPartitioning = [1, 1, 1, 1, 1]
   call partitioning(nsForPartitioning(1:1), 1, iPivot)
   TEST(iPivot == 1)
   nsForPartitioning = [1, 2, 2, 2, 2]
   call partitioning(nsForPartitioning, 1, iPivot)
   TEST(iPivot == 1)
   nsForPartitioning = [1, 2, 2, 2, 2]
   call partitioning(nsForPartitioning, 2, iPivot)
   TEST(iPivot == 5)

   ! size 0
   <%- SORTS.each{|name| -%>
      TEST(size(<%= name %>_sort([(i, i = 1, 0)])) == 0)
      TEST(size(<%= name %>_sort([(dble(i), i = 1, 0)])) == 0)
   <%- } -%>

   ! size 1
   <%- SORTS.each{|name| -%>
      TEST(all(<%= name %>_sort([0]) == [0]))
      TEST(all(almost_equal(<%= name %>_sort([0.0]), [0.0])))
   <%- } -%>

   <%- SORTS.each{|name| -%>
      <%- [SML_SETS.last].each{|sml_set| -%>
         <%- enlarge(sml_set, SCALE_UNI).each{|input, sorted| -%>
            TEST(all(<%= name %>_sort(<%= input.inspect %>) == <%= sorted.inspect %>))
         <%- } -%>

         <%- enlarge(sml_set, SCALE_I).each{|input, sorted| -%>
            TEST(all(<%= name %>_sort(<%= input.inspect %>) == <%= sorted.inspect %>))
         <%- } -%>

         <%- enlarge(sml_set, SCALE_F).each{|input, sorted| -%>
            TEST(all(almost_equal(<%= name %>_sort(<%= input.inspect %>), <%= sorted.inspect %>)))
         <%- } -%>
      <%- } -%>
   <%- } -%>

   do nDArray = 1, 2049
      allocate(dArray(nDArray))
      call random_number(dArray)
      dArray = dArray*0.01 - 0.005
      <%- SORTS.each{|name| -%>
         sortedDArray = <%= name %>_sort(dArray)
         ASSERT(all(sortedDArray(1:nDArray - 1) <= sortedDArray(2:nDArray)))
      <%- } -%>
      deallocate(dArray)
   end do
   nDArray = 10000
   allocate(dArray(nDArray))
   call random_number(dArray)
   dArray = dArray*0.01 - 0.005
   <%- SORTS.each{|name| -%>
      sortedDArray = <%= name %>_sort(dArray)
      TEST(all(sortedDArray(1:nDArray - 1) <= sortedDArray(2:nDArray)))
   <%- } -%>
   deallocate(dArray)

   ! Infinity
   <%- SORTS.each{|name| -%>
      TEST(all(almost_equal(<%= name %>_sort([0.0, get_infinity(), -get_infinity()]), [-get_infinity(), 0.0, get_infinity()])))
   <%- } -%>

   ! Bug check
   <%- SORTS.each{|name| -%>
      TEST(all(almost_equal(<%= name %>_sort([0.992602646, 0.992602706]), [0.992602646, 0.992602706])))
   <%- } -%>

   write(OUTPUT_UNIT, *) 'SUCCESS: ', __FILE__
   stop
end program sort_lib_test
