<%
  require 'fort'
  LOG_2_CHAR_LEN_MAX = 10
  REALS = ::Fort::Type::Real.multi_provide
  INTEGERS = ::Fort::Type::Integer.multi_provide
  LOGICALS = ::Fort::Type::Logical.multi_provide
  COMPLEXES = ::Fort::Type::Complex.multi_provide
  CHARACTERS = ::Fort::Type::Character.multi_provide(len: :':', len: [0]) # todo: `len: [0]` is only to avoid ICE
  TYPES\
  = REALS\
  + INTEGERS\
  + LOGICALS\
  + COMPLEXES\
  + CHARACTERS

def alloc?(t)
   t.dim > 0 || t.type == :Character
end
%>

# include "fortran_lib.h"
module stack_lib
   USE_FORTRAN_LIB_H
   <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
   implicit none

   private

   public:: push
   public:: pop

   <% TYPES.each{|t| %>
      interface push
         module procedure push<%= t %>Stack
      end interface push

      interface pop
         module procedure pop<%= t %>Stack
      end interface pop

      interface is_empty
         module procedure is_empty<%= t %>Stack
      end interface is_empty
   <% } %>

   type, public:: Stack
   end type Stack

   type:: StackNode
   end type StackNode

   <% TYPES.each{|t| %>
      type, extends(Stack), public:: <%= t %>Stack
         type(<%= t %>StackNode), pointer:: head => null()
      end type <%= t %>Stack

      type, extends(StackNode):: <%= t %>StackNode
         <%= t.declare %><%= alloc?(t) ? ', allocatable' : '' %>:: val
         type(<%= t %>StackNode), pointer:: prev => null()
      end type <%= t %>StackNode
   <% } %>

contains

   <% TYPES.each{|t| %>
      subroutine push<%= t %>Stack(self, val)
         type(<%= t %>Stack), intent(inout):: self
         <% if t.type == :Character %>
            Character(len=*), intent(in):: val
         <% else %>
            <%= t.declare %>, intent(in):: val
         <% end %>
         type(<%= t %>StackNode), pointer:: newNode

         allocate(newNode)
         newNode%val = val
         newNode%prev => self%head
         self%head => newNode
      end subroutine push<%= t %>Stack

      function pop<%= t %>Stack(self, val) result(isSuccess)
         type(<%= t %>Stack), intent(inout):: self
         <%= t.declare %><%= alloc?(t) ? ', allocatable' : '' %>, intent(inout):: val
         Logical:: isSuccess
         type(<%= t %>StackNode), pointer:: removedNode => null()

         if(is_empty(self))then
            isSuccess = .false.
            return
         end if

         val = self%head%val
         removedNode => self%head
         self%head => self%head%prev
         deallocate(removedNode)
         isSuccess = .true.
      end function pop<%= t %>Stack

      function is_empty<%= t %>Stack(self) result(answer)
         type(<%= t %>Stack), intent(in):: self
         Logical:: answer

         answer = .not.associated(self%head)
      end function is_empty<%= t %>Stack
   <% } %>
end module stack_lib
